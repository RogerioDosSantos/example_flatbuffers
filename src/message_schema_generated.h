// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MESSAGESCHEMA_BUFFER_H_
#define FLATBUFFERS_GENERATED_MESSAGESCHEMA_BUFFER_H_

#include "flatbuffers/flatbuffers.h"

namespace Buffer {

struct Bool;

struct Int;

struct Uint;

struct Long;

struct Ulong;

struct Double;

struct String;

struct Object;

enum Value {
  Value_NONE = 0,
  Value_Bool = 1,
  Value_Int = 2,
  Value_Uint = 3,
  Value_Long = 4,
  Value_Ulong = 5,
  Value_Double = 6,
  Value_String = 7,
  Value_Object = 8,
  Value_MIN = Value_NONE,
  Value_MAX = Value_Object
};

inline Value (&EnumValuesValue())[9] {
  static Value values[] = {
    Value_NONE,
    Value_Bool,
    Value_Int,
    Value_Uint,
    Value_Long,
    Value_Ulong,
    Value_Double,
    Value_String,
    Value_Object
  };
  return values;
}

inline const char **EnumNamesValue() {
  static const char *names[] = {
    "NONE",
    "Bool",
    "Int",
    "Uint",
    "Long",
    "Ulong",
    "Double",
    "String",
    "Object",
    nullptr
  };
  return names;
}

inline const char *EnumNameValue(Value e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesValue()[index];
}

template<typename T> struct ValueTraits {
  static const Value enum_value = Value_NONE;
};

template<> struct ValueTraits<Bool> {
  static const Value enum_value = Value_Bool;
};

template<> struct ValueTraits<Int> {
  static const Value enum_value = Value_Int;
};

template<> struct ValueTraits<Uint> {
  static const Value enum_value = Value_Uint;
};

template<> struct ValueTraits<Long> {
  static const Value enum_value = Value_Long;
};

template<> struct ValueTraits<Ulong> {
  static const Value enum_value = Value_Ulong;
};

template<> struct ValueTraits<Double> {
  static const Value enum_value = Value_Double;
};

template<> struct ValueTraits<String> {
  static const Value enum_value = Value_String;
};

template<> struct ValueTraits<Object> {
  static const Value enum_value = Value_Object;
};

bool VerifyValue(flatbuffers::Verifier &verifier, const void *obj, Value type);
bool VerifyValueVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum KeyType {
  KeyType_Name = 0,
  KeyType_TimeStamp = 1,
  KeyType_MIN = KeyType_Name,
  KeyType_MAX = KeyType_TimeStamp
};

inline KeyType (&EnumValuesKeyType())[2] {
  static KeyType values[] = {
    KeyType_Name,
    KeyType_TimeStamp
  };
  return values;
}

inline const char **EnumNamesKeyType() {
  static const char *names[] = {
    "Name",
    "TimeStamp",
    nullptr
  };
  return names;
}

inline const char *EnumNameKeyType(KeyType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesKeyType()[index];
}

struct Bool FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_VALUE = 4
  };
  bool value() const {
    return GetField<uint8_t>(VT_VALUE, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct BoolBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(bool value) {
    fbb_.AddElement<uint8_t>(Bool::VT_VALUE, static_cast<uint8_t>(value), 0);
  }
  explicit BoolBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BoolBuilder &operator=(const BoolBuilder &);
  flatbuffers::Offset<Bool> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Bool>(end);
    return o;
  }
};

inline flatbuffers::Offset<Bool> CreateBool(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool value = false) {
  BoolBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct Int FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_VALUE = 4
  };
  int32_t value() const {
    return GetField<int32_t>(VT_VALUE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct IntBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(int32_t value) {
    fbb_.AddElement<int32_t>(Int::VT_VALUE, value, 0);
  }
  explicit IntBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  IntBuilder &operator=(const IntBuilder &);
  flatbuffers::Offset<Int> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Int>(end);
    return o;
  }
};

inline flatbuffers::Offset<Int> CreateInt(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t value = 0) {
  IntBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct Uint FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_VALUE = 4
  };
  uint32_t value() const {
    return GetField<uint32_t>(VT_VALUE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct UintBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(uint32_t value) {
    fbb_.AddElement<uint32_t>(Uint::VT_VALUE, value, 0);
  }
  explicit UintBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UintBuilder &operator=(const UintBuilder &);
  flatbuffers::Offset<Uint> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Uint>(end);
    return o;
  }
};

inline flatbuffers::Offset<Uint> CreateUint(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t value = 0) {
  UintBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct Long FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_VALUE = 4
  };
  int64_t value() const {
    return GetField<int64_t>(VT_VALUE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct LongBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(int64_t value) {
    fbb_.AddElement<int64_t>(Long::VT_VALUE, value, 0);
  }
  explicit LongBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LongBuilder &operator=(const LongBuilder &);
  flatbuffers::Offset<Long> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Long>(end);
    return o;
  }
};

inline flatbuffers::Offset<Long> CreateLong(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t value = 0) {
  LongBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct Ulong FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_VALUE = 4
  };
  uint64_t value() const {
    return GetField<uint64_t>(VT_VALUE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct UlongBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(uint64_t value) {
    fbb_.AddElement<uint64_t>(Ulong::VT_VALUE, value, 0);
  }
  explicit UlongBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UlongBuilder &operator=(const UlongBuilder &);
  flatbuffers::Offset<Ulong> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Ulong>(end);
    return o;
  }
};

inline flatbuffers::Offset<Ulong> CreateUlong(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t value = 0) {
  UlongBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct Double FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_VALUE = 4
  };
  double value() const {
    return GetField<double>(VT_VALUE, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct DoubleBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(double value) {
    fbb_.AddElement<double>(Double::VT_VALUE, value, 0.0);
  }
  explicit DoubleBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DoubleBuilder &operator=(const DoubleBuilder &);
  flatbuffers::Offset<Double> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Double>(end);
    return o;
  }
};

inline flatbuffers::Offset<Double> CreateDouble(
    flatbuffers::FlatBufferBuilder &_fbb,
    double value = 0.0) {
  DoubleBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct String FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_VALUE = 4
  };
  const flatbuffers::String *value() const {
    return GetPointer<const flatbuffers::String *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.Verify(value()) &&
           verifier.EndTable();
  }
};

struct StringBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(flatbuffers::Offset<flatbuffers::String> value) {
    fbb_.AddOffset(String::VT_VALUE, value);
  }
  explicit StringBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StringBuilder &operator=(const StringBuilder &);
  flatbuffers::Offset<String> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<String>(end);
    return o;
  }
};

inline flatbuffers::Offset<String> CreateString(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> value = 0) {
  StringBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

inline flatbuffers::Offset<String> CreateStringDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *value = nullptr) {
  return Buffer::CreateString(
      _fbb,
      value ? _fbb.CreateString(value) : 0);
}

struct Object FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_KEY = 4,
    VT_KEY_TYPE = 6,
    VT_TIMESTAMP = 8,
    VT_NAME = 10,
    VT_VALUE_TYPE = 12,
    VT_VALUE = 14,
    VT_OBJECTS = 16
  };
  const flatbuffers::String *key() const {
    return GetPointer<const flatbuffers::String *>(VT_KEY);
  }
  bool KeyCompareLessThan(const Object *o) const {
    return *key() < *o->key();
  }
  int KeyCompareWithValue(const char *val) const {
    return strcmp(key()->c_str(), val);
  }
  KeyType key_type() const {
    return static_cast<KeyType>(GetField<int8_t>(VT_KEY_TYPE, 0));
  }
  const flatbuffers::String *timestamp() const {
    return GetPointer<const flatbuffers::String *>(VT_TIMESTAMP);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  Value value_type() const {
    return static_cast<Value>(GetField<uint8_t>(VT_VALUE_TYPE, 0));
  }
  const void *value() const {
    return GetPointer<const void *>(VT_VALUE);
  }
  template<typename T> const T *value_as() const;
  const Bool *value_as_Bool() const {
    return value_type() == Value_Bool ? static_cast<const Bool *>(value()) : nullptr;
  }
  const Int *value_as_Int() const {
    return value_type() == Value_Int ? static_cast<const Int *>(value()) : nullptr;
  }
  const Uint *value_as_Uint() const {
    return value_type() == Value_Uint ? static_cast<const Uint *>(value()) : nullptr;
  }
  const Long *value_as_Long() const {
    return value_type() == Value_Long ? static_cast<const Long *>(value()) : nullptr;
  }
  const Ulong *value_as_Ulong() const {
    return value_type() == Value_Ulong ? static_cast<const Ulong *>(value()) : nullptr;
  }
  const Double *value_as_Double() const {
    return value_type() == Value_Double ? static_cast<const Double *>(value()) : nullptr;
  }
  const String *value_as_String() const {
    return value_type() == Value_String ? static_cast<const String *>(value()) : nullptr;
  }
  const Object *value_as_Object() const {
    return value_type() == Value_Object ? static_cast<const Object *>(value()) : nullptr;
  }
  const flatbuffers::Vector<flatbuffers::Offset<Object>> *objects() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Object>> *>(VT_OBJECTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_KEY) &&
           verifier.Verify(key()) &&
           VerifyField<int8_t>(verifier, VT_KEY_TYPE) &&
           VerifyOffset(verifier, VT_TIMESTAMP) &&
           verifier.Verify(timestamp()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyField<uint8_t>(verifier, VT_VALUE_TYPE) &&
           VerifyOffset(verifier, VT_VALUE) &&
           VerifyValue(verifier, value(), value_type()) &&
           VerifyOffset(verifier, VT_OBJECTS) &&
           verifier.Verify(objects()) &&
           verifier.VerifyVectorOfTables(objects()) &&
           verifier.EndTable();
  }
};

template<> inline const Bool *Object::value_as<Bool>() const {
  return value_as_Bool();
}

template<> inline const Int *Object::value_as<Int>() const {
  return value_as_Int();
}

template<> inline const Uint *Object::value_as<Uint>() const {
  return value_as_Uint();
}

template<> inline const Long *Object::value_as<Long>() const {
  return value_as_Long();
}

template<> inline const Ulong *Object::value_as<Ulong>() const {
  return value_as_Ulong();
}

template<> inline const Double *Object::value_as<Double>() const {
  return value_as_Double();
}

template<> inline const String *Object::value_as<String>() const {
  return value_as_String();
}

template<> inline const Object *Object::value_as<Object>() const {
  return value_as_Object();
}

struct ObjectBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_key(flatbuffers::Offset<flatbuffers::String> key) {
    fbb_.AddOffset(Object::VT_KEY, key);
  }
  void add_key_type(KeyType key_type) {
    fbb_.AddElement<int8_t>(Object::VT_KEY_TYPE, static_cast<int8_t>(key_type), 0);
  }
  void add_timestamp(flatbuffers::Offset<flatbuffers::String> timestamp) {
    fbb_.AddOffset(Object::VT_TIMESTAMP, timestamp);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Object::VT_NAME, name);
  }
  void add_value_type(Value value_type) {
    fbb_.AddElement<uint8_t>(Object::VT_VALUE_TYPE, static_cast<uint8_t>(value_type), 0);
  }
  void add_value(flatbuffers::Offset<void> value) {
    fbb_.AddOffset(Object::VT_VALUE, value);
  }
  void add_objects(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Object>>> objects) {
    fbb_.AddOffset(Object::VT_OBJECTS, objects);
  }
  explicit ObjectBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ObjectBuilder &operator=(const ObjectBuilder &);
  flatbuffers::Offset<Object> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Object>(end);
    fbb_.Required(o, Object::VT_KEY);
    return o;
  }
};

inline flatbuffers::Offset<Object> CreateObject(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> key = 0,
    KeyType key_type = KeyType_Name,
    flatbuffers::Offset<flatbuffers::String> timestamp = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    Value value_type = Value_NONE,
    flatbuffers::Offset<void> value = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Object>>> objects = 0) {
  ObjectBuilder builder_(_fbb);
  builder_.add_objects(objects);
  builder_.add_value(value);
  builder_.add_name(name);
  builder_.add_timestamp(timestamp);
  builder_.add_key(key);
  builder_.add_value_type(value_type);
  builder_.add_key_type(key_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Object> CreateObjectDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *key = nullptr,
    KeyType key_type = KeyType_Name,
    const char *timestamp = nullptr,
    const char *name = nullptr,
    Value value_type = Value_NONE,
    flatbuffers::Offset<void> value = 0,
    const std::vector<flatbuffers::Offset<Object>> *objects = nullptr) {
  return Buffer::CreateObject(
      _fbb,
      key ? _fbb.CreateString(key) : 0,
      key_type,
      timestamp ? _fbb.CreateString(timestamp) : 0,
      name ? _fbb.CreateString(name) : 0,
      value_type,
      value,
      objects ? _fbb.CreateVector<flatbuffers::Offset<Object>>(*objects) : 0);
}

inline bool VerifyValue(flatbuffers::Verifier &verifier, const void *obj, Value type) {
  switch (type) {
    case Value_NONE: {
      return true;
    }
    case Value_Bool: {
      auto ptr = reinterpret_cast<const Bool *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Value_Int: {
      auto ptr = reinterpret_cast<const Int *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Value_Uint: {
      auto ptr = reinterpret_cast<const Uint *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Value_Long: {
      auto ptr = reinterpret_cast<const Long *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Value_Ulong: {
      auto ptr = reinterpret_cast<const Ulong *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Value_Double: {
      auto ptr = reinterpret_cast<const Double *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Value_String: {
      auto ptr = reinterpret_cast<const String *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Value_Object: {
      auto ptr = reinterpret_cast<const Object *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyValueVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyValue(
        verifier,  values->Get(i), types->GetEnum<Value>(i))) {
      return false;
    }
  }
  return true;
}

inline const Buffer::Object *GetObject(const void *buf) {
  return flatbuffers::GetRoot<Buffer::Object>(buf);
}

inline bool VerifyObjectBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<Buffer::Object>(nullptr);
}

inline void FinishObjectBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<Buffer::Object> root) {
  fbb.Finish(root);
}

}  // namespace Buffer

#endif  // FLATBUFFERS_GENERATED_MESSAGESCHEMA_BUFFER_H_
